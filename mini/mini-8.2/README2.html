<html>
<head>
<title>libMini Usage Guide</title>
<link rel="stylesheet" type="text/css" href="libMini.css">
</head>
<body>

<a name=""></a>
<h1>libMini Usage Guide</h1>

I hope this small guide will allow you to better understand the basic
principles of the Mini Library and will facilitate its integration
into your own applications.<p>

Original version by Olivier Pascal.<br>
Amended by Stefan Roettger.<p>

<a name="Overview"></a>
<h2>Overview</h2>

What you must know about...<p>

<ul>
   <li><a href="#Height_field_and_texture_generation">(A) Height field and texture generation</a></li>
   <li><a href="#Loading_the_tiles">(B) Loading the tiles</a></li>
   <li><a href="#Multi-threading">(C) Multi-threading</a></li>
   <li><a href="#Texture_compression">(D) Texture compression</a></li>
   <li><a href="#Texture_mip-mapping">(E) Texture mip-mapping</a></li>
   <li><a href="#The_file_cache">(F) The file cache</a></li>
   <li><a href="#The_vertex_cache">(G) The vertex cache</a></li>
   <li><a href="#Using_a_terrain_shader">(H) Using a terrain shader</a></li>
   <li><a href="#Waypoints">(I) Waypoints</a></li>
   <li><a href="#Skydomes">(J) Skydomes</a></li>
</ul>

<a href="#" class="top">Back to top</a>

<a name="Height_field_and_texture_generation"></a>
<h2>(A) Height field and texture generation</h2>

Height fields and textures are treated exactly the same with the only
difference that the size of height fields is 2^n+1 and the size of
textures is 2^n.<p>

Large height fields or textures are usually broken up into tile
sets. The layout of the tiles has to be uniform, but libMini allows to
have different data sizes for each tile.<p>

To avoid gaps between the tiles, you have to ensure that the shared
grid points of two adjacent tiles are exactly the same, which means
that the shared edges must be duplicated.<p>

It can be delicate to satisfy this rule when additional levels of
detail have to be generated. The following resampling method can be
used: Just think of a checkerboard of 8x8 fields which has 9x9 data
points located at the field corners. Then the generation of 4 tiles is
equal to cutting the board into 4 quads with a saw. To generate a tile
with reduced resolution, we just drop every second data point in each
dimension! This resampling method is implemented in the file
<em>pnmsample.cpp</em>.<p> The <em>resample</em> method takes a list
of (rotated and/or translated) source images and produces a tile set
that is resampled uniformly within a given bounding box (the first
image on the list). The resolution of each tile is adapted to the
maximum resolution of the source images within the tile area.

Some usage examples are given in the libMini demos <a
href="http://stereofx.org/download/Hawaii.zip">Hawaii</a> and <a
href="http://stereofx.org/download/Fraenkische.zip">Fraenkische</a>.<p>

Height fields and textures can be saved in the PNM format (PGM/PPM for
grayscale/RGB images), but the native DB format of the Mini Library
should be preferred. It is possible to easily convert PNM data to the
native format by using the <em>databuf</em> object to import a PNM
file and to export it in the native format.<p>

Each height field or texture must be georeferenced, which means that
the corresponding images have to contain the necessary information to
locate them geographically. This is achieved by defining the corner
coordinates in a reference coordinate system.<p>

Example of a georeferenced PPM header:<p>

<pre>
   P6
   # BOX
   # description=PPM example
   # coordinate system=LL
   # coordinate zone=0
   # coordinate datum=0
   # SW corner=198721.93993200/-75123.60940800 arc-seconds
   # NW corner=198722.01794400/-75081.99117600 arc-seconds
   # NE corner=198766.29376800/-75082.06288800 arc-seconds
   # SE corner=198766.21917600/-75123.68115600 arc-seconds
   # cell size=.086482/.086482 arc-seconds
   # vertical scaling=0 meters
   # missing value=-9999
   512 512
   255
</pre>

The georeferencing information can be automatically generated by the
PNM writing methods in <em>pnmbase.cpp</em>. Then the images can be
converted into the native format with the <em>loadPNMdata</em> method
of a <em>databuf</em> object. After that, the contents of the databuf
object may be dumped and loaded in the native DB format via the
<em>savedata</em>/<em>loaddata</em> methods. The native format has the
extension ".db".<p>

The header of an RGB image in the libMini native format:<p>

<pre>
   MAGIC=12640
   xsize=512
   ysize=512
   zsize=1
   tsteps=1
   type=5
   swx=198721.937500
   swy=-75123.609375
   nwx=198722.015625
   nwy=-75081.992188
   nex=198766.296875
   ney=-75082.062500
   sex=198766.218750
   sey=-75123.679688
   h0=0.000000
   dh=0.000000
   t0=0.000000
   dt=0.000000
   scaling=0.000000
   bias=0.000000
   bytes=131072
</pre>

An image type of 5 identifies RGB images whereas an image type of 2
identifies 32-bit floating point height fields (see
<em>database.hpp</em> for a list of possible values and their
meanings).<p>

<a href="#" class="top">Back to top</a>

<a name="Loading_the_tiles"></a>
<h2>(B) Loading the tiles</h2>

A tiled terrain is initialized with the code below:<p>

<pre>
   miniload terrain;

   float outparams[5],arcsec[2];

   terrain.load(cols,rows,
                basepath1,basepath2,NULL,
                offsetlat,offsetlon,
                exaggeration,scale,
                0.0f,0.0f,0.0f,0.0f,
                outparams,arcsec);
</pre>

The parameters have the following meaning:<p>

<ul>
   <li>cols: number of columns of the tile set</li>
   <li>rows: number of rows of the tile set</li>
   <li>basepath1: path to the DEM tiles</li>
   <li>basepath2: path to the texture tiles</li>
   <li>offsetlat: latitude offset</li>
   <li>offsetlon: longitude offset</li>
   <li>exaggeration: additional scaling of the elevations</li>
   <li>scale: additional scaling of the world coordinate system</li>
</ul>

The array <em>outparams</em> will be filled with these values:<p>

<ul>

<li><em>outparams[0]</em> and <em>outparams[1]</em> correspond to the
size of a single tile</li>

<li><em>outparams[2]</em> and <em>outparams[3]</em> correspond to the
terrain offset of the center of the entire grid (in the x- and
z-direction)</li>

<li><em>outparams[4]</em> contains the maximum elevation of the entire
grid (along the y-direction)</li>

<li><em>arcsec[0]</em> and <em>arcsec[1]</em> correspond to the
approximate size of one arc-second in meters (in the x- and
z-direction)</li>

</ul>

<div class="note">
<b>Note:</b> Another possible method to load a terrain is to use the
optional <em>miniload</em> constructor, for which it is necessary to
pass all the parameters manually. So the previously described approach
is usually more convenient.
</div>

Before the first frame can be rendered, the visible tiles have to be
loaded. The selection of the LODs to be loaded is driven by the
user-defined screen space error (or resolution). The library always
loads the LODs directly from disk except for the case that a
<em>request</em> callback is defined. Then the task of the callback is
to load the specified tiles and return the data to the library. This
is useful if the data is arriving through a socket, for example. When
all the visible tiles have been loaded into memory, the library will
start to preload the next visible LODs through the <em>preload</em>
callback. The library will trigger the <em>deliver</em> callback
regularly to see whether or not the data has already arrived. Thus, if
the camera doesn't move too quickly nor too abruptly, all the
necessary tiles will have already been delivered before they actually
become visible.<p>

During the initial phase, all height fields and textures are loaded
systematically by the library. There is no way to omit tiles in this
phase, but you could decrease startup time by specifying a lower
resolution and increase it later. The <em>request</em> callback thus
always needs to return a height field. Depending on the request it may
also return a texture.<p>

After this phase, the loading of a texture can be either omitted or
delayed in order to schedule the data traffic coming from the hard
disk (or through a socket). The <em>preload</em> callback indicates
the start of a preloading activity and the <em>deliver</em> callback
can return either no data at all, or a height field or both a height
field and a texture. In the case, for example, where the data traffic
is quite high, we could wait with the delivery of a texture until the
traffic has settled to a lower level. However, the callback cannot
return a texture without the associated height field.<p>

<a href="#" class="top">Back to top</a>

<a name="Multi-threading"></a>
<h2>(C) Multi-threading</h2>

If you use the preloading system, you should spawn a thread for each
tile in order to decouple the storage of the incoming data from
rendering. Both the <em>loadPNMdata</em> and the <em>loaddata</em>
method of a <em>databuf</em> object are reentrant, which means that
they can be used to load data simultaneously in multiple
threads. However, some operating systems do not support reentrant file
IO. In such a case the IO operation must be locked with a mutex.<p>

<a href="#" class="top">Back to top</a>

<a name="Texture_compression"></a>
<h2>(D) Texture compression</h2>

There are three possible scenarios concerning textures compression:<p>

<ul>

<li>If texture compression is not used, the Mini Library will load the
textures and send them to the GPU in a non-compressed format.</li>

<li>If texture compression is enabled and if non-compressed textures
are loaded, the Mini Library will try to compress them on-the-fly and
send them to the GPU in a compressed format.</li>

<li>If texture compression is enabled and if compressed textures are
loaded in S3TC/DXT1 format, the Mini Library will transmit the data
directly to the GPU without performing an on-the-fly compression. This
is obviously an enormous performance gain both in the loading time and
in sending the data to the GPU but also in saving space in the
graphics memory and on the file system. To give you an example, our
test data set dropped from 2.6 GB of texture memory to a mere 533 MB
without any significant loss of visual quality!</li>

</ul>

<div class="note">
<b>Note:</b> Saving and loading of pre-compressed textures in
S3TC/DXT1 format is only possible with the native format of the Mini
Library. Therefore, the PNM format is deprecated and should only be
used for the storage of plain images in the future.
</div>

<a href="#" class="top">Back to top</a>

<a name="Texture_mip-mapping"></a>
<h2>(E) Texture mip-mapping</h2>

The Mini Library dynamically sends samples of textures of decreasing
resolutions to the GPU. According to the distance from the camera and
the necessary level of detail these samples replace the previously
loaded texture. This can lead to latencies because the mipmap textures
have to be generated on-the-fly. For particularly large textures, you
should disable mip-mapping with the <em>configure_mipmaps</em> method
of the <em>miniload</em> object. Pre-compressed textures automatically
inhibit mip-mapping for performance reasons.<p>

<a href="#" class="top">Back to top</a>

<a name="The_file_cache"></a>
<h2>(F) The file cache</h2>

If a texture (or a height field) has already been loaded and the
correct LOD is also enabled, then the texture (or the height field)
never will be loaded a second time. It will be loaded again only if
the camera position moved forth and back again to the original point
of view (the Mini Library doesn't implement a cache, this is left to
the application). So in general, it is a good idea to implement a file
caching system by yourself. The actual version of VTEnviro from
vterrain.org implements such a cache.<p>

<div class="note">
<b>Note:</b> The file system also implements caching, so if a tile is
loaded a second time it should be faster anyway, but you cannot rely
on the caching to be persistent. Most file systems invalidate the
contents of their cache if it has not been used for a certain time. On
a Linux box the caching time seems to be less than a minute.
</div>

However, some double requests can appear in the initial loading phase
in the <em>request</em> callback. This is a normal behaviour and is
due to the fact that the Mini Library has to figure out how many LODs
are actually present for each tile.<p>

<a href="#" class="top">Back to top</a>

<a name="The_vertex_cache"></a>
<h2>(G) The vertex cache</h2>

To use the vertex cache implemented in the <em>minicache</em> the
following two steps are required:<p>

First you have to instantiate the <em>minicache</em> class and
initialize the vertex cache system by passing several parameters: a
pointer to the <em>minitile</em> object, the columns and rows of the
terrain grid, the width and height of a tile (available in
<em>outparams[0]</em> and <em>outparams[1]</em>) and finally the
terrain offset.<p>

<pre>
   minicache cache;
   cache.setcallbacks(terrain->getminitile(),cols,rows,tilew,tileh,off.x,off.y,off.z);
</pre>

When the terrain is rendered with <em>miniload::draw</em>, the
generated vertices are not yet passed to the graphics
hardware. Instead they are recorded in a vertex array (VA) which is
managed by the minicache object. The contents of the VA may persist
during several frames and are finally passed to the graphics hardware
by calling the <em>cache::rendercache</em> method. The <em>update</em>
parameter of the <em>miniload::draw</em> method defines the number of
frames during which the cache is updated step by step. The longer the
cache persistence the smaller the CPU load.<p>

<a href="#" class="top">Back to top</a>

<a name="Using_a_terrain_shader"></a>
<h2>(H) Using a terrain shader</h2>

If you want to apply a vertex or pixel shader to the terrain generated
by the Mini Library it is recommended that you just use the vertex
shader plugins of the minicache. You could also use the library stub
which sends all vertices through a callback so that you can take care
of the OpenGL state by yourself. But this involves a lot of extra
work, so that the easiest approach is to pass your own shader programs
to the minicache via <em>minicache::setvtxshader/setpixshader</em>.<p>

<a href="#" class="top">Back to top</a>

<a name="Waypoints"></a>
<h2>(I) Waypoints:</h2>

The Mini Library proposes a point of interest management system via
the <em>minipoint</em> object. An example usage of this system can be
found in
the <a href="http://stereofx.org/download/Fraenkische.zip">Fraenkische
Demo</a>.<p>

The data file describing the points of interest is a simple ASCII
file, whose waypoint records are defined by 5 consecutive text
lines:<p>

<ul>

<li>the first line contains the meta-information of the point, whose
first field (separated from the others by the field delimiter ';')
corresponds to the description of the point</li>

<li>the second line describes the world coordinate system (can be
<em>UTM &lt;x&gt;</em> for the Universal Transverse Mercator
projection zone x or <em>LL</em> for Latitude/Longitude</li>

<li>the third and the fourth line contain the point coordinates (in
meters for UTM and degrees for LL)</li>

<li>the fifth line contains the elevation of the point (in
meters)</li>

</ul>

Here is an example file:<p>

<pre>
   Point de départ;départ
   UTM 32
   0660181
   5501986
   499m

   Saint-Denis;ville
   LL
   -20.877817797774004
   55.447862996268931
   28m
</pre>

Given the terrain has been loaded as described in
Section <a href="#Loading_the_tiles">(B)</a> then the following code
loads the waypoint file into a <em>minipoint</em> object:<p>

<pre>
   minipoint points;
   points.load("waypoints.txt",off.x,off.z,arcsec[0],arcsec[1],exaggeration/scale,terrain.getminitile());
</pre>

Now here is an example code snippet for browsing the points:<p>

<pre>
   <span class="comment">// All visible points are automatically determined</span>
   points.calcvdata();
   <span class="comment">// Get all visible points</span>
   minipointdata **vpoint = points.getvdata();
   <span class="comment">// Get the nearest point</span>
   minipointdata *nearest = points.getnearest(camera.x,camera.y,camera.z);
   <span class="comment">// Abort if there is no visible point</span>
   if (vpoint == NULL) return;
   <span class="comment">// Define a visibility range</span>
   float pointrange = 0.15f*farp/scale;

   <span class="comment">// Browse all visible points</span>
   for (int i=0; i&lt;points.getvnum(); i++, vpoint++)
      {
      <span class="comment">// Verify that the point is inside the defined visibility range</span>
      if (points.getdistance2(camera.x,camera.z,camera.y,*vpoint)&lt;fsqr(pointrange))
         {
         <span class="comment">// Render the point or do whatever you want</span>
         <span class="comment">// ...</span>
         }
   }
</pre>

Each point of interest has the following attributes:<p>

<ul>
   <li><b>vpoint->desc</b>: the point description</li>
   <li><b>vpoint->meta</b>: the meta-information separated by a field delimiter</li>
   <li><b>vpoint->x</b>, <b>vpoint->y</b>: the actual (transformed) point coordinates</li>
   <li><b>vpoint->longitude</b>, <b>vpoint->latitude</b>: the point coordinates as defined in the file</li>
   <li><b>vpoint->height</b>: the height of the terrain at the point in meters</li>
   <li><b>vpoint->elevation</b>: the elevation of the point in meters as defined in the file</li>
</ul>

<a href="#" class="top">Back to top</a>

<a name="Skydomes"></a>
<h2>(J) Skydomes</h2>

A simple usage example is given in the <a
href="http://stereofx.org/download/Hawaii.zip">Hawaii Demo</a>.<p>

Loading a skydome:<p>

<pre>
   minisky skydome;
   skydome.loadskydome("SkyDome.ppm",outparams[2],0.0f,-outparams[3],cols*outparams[0],rows*outparams[1]/(cols*outparams[0]));
</pre>

Render the skydome with <em>skydome.drawskydome();</em>.<p>

The skydome will be as large as the terrain. If you move the point of
view you might want to move the center of the skydome as well. Be sure
not to make the skydome larger than the actual distance to the far
clipping plane.<p>

<a href="#" class="top">Back to top</a>

<small>end</small><p>

</body>
</html>
